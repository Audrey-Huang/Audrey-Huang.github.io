---
layout:     post
title:      "Basic knowledge of HTTP"
subtitle:   "HTTP必备知识"
date:       2021-03-10
author:     "Audrey"
header-img: "img/post-http-basic-2021.jpg"
catalog: true
hidden: true
tags:
    - Web前端
    - HTTP
---
### HTTP报文

HTTP报文就是浏览器和服务器通信时发送及响应的数据块。

浏览器向服务器请求数据，发送请求报文；服务器向浏览器返回数据，返回响应报文。

##### 报文信息主要分为

1. header：附加信息(cookie，缓存信息等)
2. body：HTTP请求真正要传输的部分

### HTTP首部

首部是客户端和服务器分别处理请求和响应所需要的信息。

![img](https://images2015.cnblogs.com/blog/747969/201702/747969-20170217213700816-2042027085.png)

#### 格式

首部字段名: 字段值

#### 字段类型

* 通用首部字段

  请求和响应报文都会使用的首部

   ![img](https://images2015.cnblogs.com/blog/747969/201702/747969-20170217213940879-276855677.png)

* 请求首部字段

  请求的附加内容、客户端信息、响应内容优先级等

* 响应首部字段

  响应的附加内容

* 实体首部字段

  针对请求报文和响应报文的实体部分使用的首部

### HTTP缓存机制

#### 强制缓存

强制缓存在数据未失效的情况下，可以直接使用缓存数据。那么**如何判断缓存数据是否失效**呢？

因为没有数据时，会向服务器请求数据，此时会返回数据和缓存规则，缓存规则包含在响应的header中。对于强制缓存来说，header中会有两个字段来标明失效规则。

* expires

  服务端返回的到期时间，下一次请求时，如果请求时间小于到期时间，直接使用缓存数据。（不常使用，而且因为服务端与客户端的时差问题，会导致命中误差。

* cache-control

  * private：客户端可以缓存（默认）
  * public：客户端和代理服务器都可以缓存
  * max-age=xxx：在xxx秒后缓存内容失效
  * no-cache：需要使用对比缓存来验证缓存数据
  * no-store：所有的内容都不会缓存

![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210135521072-1812985836.png)

#### 对比缓存

需要比较判断是否可以使用缓存。

请求数据时，客户端将备份的**缓存标识**发送给服务器，服务器根据标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。

服务器在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不需要把报文主体返回给客户端。

**缓存标识**在请求header和响应header之间进行传递。

* last-modified：服务器在响应请求时，告诉浏览器的最后修改时间（第一次请求时
* if-modified-since：再次请求服务器时，通过此字段通知服务器上次请求时服务器返回资源的最后修改时间。服务器收到请求后，发现有该标识，则与被请求资源的最后修改时间进行对比。
  * 如果最后修改时间大于if-modified-since，则资源又被改动，返回200
  * 如果小于或等于，则资源无新修改，则相应304，可以使用缓存
* Etag：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（第一次请求时，优先级高于last-modified
* if-none-match： 再次请求服务器时，通过此字段通知服务器客户端缓存数据的唯一标识。
  * 如果两者不同，则资源被改动，返回200
  * 如果相同，则资源无改动，返回304，可继续使用缓存

![img](https://images2015.cnblogs.com/blog/632130/201702/632130-20170210141716838-764535017.png)

### GET&POST的区别

两者都是HTTP协议的请求方式，输入TCP/IP应用层的协议。

本质上都是TCP连接，没有什么区别，但在前端开发中，应对浏览器和服务器的规则，有了以下几点区别：

1.GET的数据是写在URL中，POST数据是存放在request body中，因此GET可能会带来安全问题；

2.一般浏览器的URL限制在2048b，所以GET传输数据时有大小限制；

3.GET请求，一次产生一个数据包，二POST请求产生两个数据包，先传输header，后传输body。



### TCP和UDP区别

TCP传输控制协议，UDP用户数据报协议

**TCP是面向连接的协议，建立连接过程涉及三次握手，四次挥手。**

**三次握手**：***\*为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误\****”

1. ​    首先客户端向服务器发送SKY消息，并进入SYN_SEND状态
2. ​    服务器监听端口收到后回复SKY-ACK消息
3. ​    客户端接收到消息后会再回复一个ACK消息。一旦服务器接收到ACK消息时，连接就建立了。

**四次挥手：**双方都发送FIN告知对方要关闭了

1. 客户端发送一个FIN，用来关闭客户端到服务端的数据传送。
2. 服务端收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1。
3. 服务端发送一个FIN，用来关闭服务端到客户端的数据传送。
4. 客户端收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。

 **UDP不需要连接，数据包带有目的地的IP地址和端口就去寻找服务器了。**

2.**tcp传输时是可靠的，udp传输时是不可靠的。**tcp有个以字节为单位的滑动窗口，它把要发送的数据都以字节形式存储在这个滑动窗口当中。每次发送完窗口的数据后，都会先保留数据，只有当收到对方的数据确认收到信号时再清除这些数据，如果超时没有收到确认信号的话就要重传。这就是tcp的**确认重传机制**。主要是利用了tcp首部的各个信号位。确认最后一个到达的字符的序号。**所以udp相比之下容易丢包，报文乱序。**

3.要想UDP保证稳定连接，可以也为UDP添加一个确认重传机制，或者添加seq/ack机制，确保数据发送到对端，添加发送和接受缓存区。